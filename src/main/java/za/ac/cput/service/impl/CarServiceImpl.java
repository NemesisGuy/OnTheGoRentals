package za.ac.cput.service.impl;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import za.ac.cput.domain.entity.Car;
import za.ac.cput.domain.enums.PriceGroup;
// import za.ac.cput.factory.impl.CarFactory; // Factory usage seems to be removed or implicit
import za.ac.cput.exception.ResourceNotFoundException;
import za.ac.cput.repository.CarRepository; // Use interface
import za.ac.cput.service.ICarService;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

/**
 * CarServiceImpl.java
 * Implementation of the {@link ICarService} interface.
 * Provides business logic for managing Car entities, including CRUD operations
 * and querying cars based on various criteria.
 *
 * Author: Peter Buckingham (220165289)
 * Date: [Original Date - Please specify if known]
 * Updated by: Peter Buckingham
 * Updated: 2025-05-28
 */
@Service("carServiceImpl") // Bean name specified
@Transactional
public class CarServiceImpl implements ICarService {

    private static final Logger log = LoggerFactory.getLogger(CarServiceImpl.class);
    private final CarRepository carRepository; // Use interface, renamed for clarity
    // private final CarFactory carFactory; // Commented out as it seems direct entity creation is used

    /**
     * Constructs the CarServiceImpl.
     *
     * @param carRepository The repository for car data persistence.
     * //@param carFactory  The factory for creating Car instances (if used).
     */
    @Autowired
    public CarServiceImpl(CarRepository carRepository /*, CarFactory carFactory */) {
        this.carRepository = carRepository;
        // this.carFactory = carFactory; // If factory pattern is strictly followed for creation
        log.info("CarServiceImpl initialized.");
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Car create(Car car) {
        log.info("Attempting to create new car. Make: '{}', Model: '{}'", car.getMake(), car.getModel());
        // Ensure UUID is set if not provided and not auto-generated by DB/JPA @PrePersist



        // If using a factory explicitly:
        // Car newCarInstance = carFactory.create(car.getMake(), car.getModel(), ..., car.getUuid(), car.isAvailable(), car.isDeleted());
        // For now, assuming 'car' parameter is the entity to be persisted.
        Car savedCar = carRepository.save(car);
        log.info("Successfully created car. ID: {}, UUID: {}, Make: '{}', Model: '{}'",
                savedCar.getId(), savedCar.getUuid(), savedCar.getMake(), savedCar.getModel());
        return savedCar;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Car read(Integer id) {
        log.debug("Attempting to read car by internal ID: {}", id);
        Optional<Car> optionalCar = this.carRepository.findByIdAndDeletedFalse(id); // Use soft-delete aware method
        if (optionalCar.isPresent()) {
            Car car = optionalCar.get();
            log.debug("Car found for ID: {}. UUID: '{}', Make: '{}'", id, car.getUuid(), car.getMake());
            return car;
        }
        log.warn("Car not found or is deleted for ID: {}", id);
        return null;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Car read(UUID carUuid) {
        log.debug("Attempting to read car by UUID: '{}'", carUuid);
        // Ensure repository has findByUuidAndDeletedFalse or similar
        Optional<Car> optionalCar = this.carRepository.findByUuidAndDeletedFalse(carUuid);
        if (optionalCar.isPresent()) {
            Car car = optionalCar.get();
            log.debug("Car found for UUID: '{}'. ID: {}, Make: '{}'", carUuid, car.getId(), car.getMake());
            return car;
        }
        log.warn("Car not found or is deleted for UUID: '{}'", carUuid);
        return null;
    }


    /**
     * {@inheritDoc}
     */
    @Override
    public Car update(Car car) { // Assumes 'car' entity has the ID of the record to update
        log.info("Attempting to update car with ID: {} and UUID: '{}'", car.getId(), car.getUuid());
        if (car.getId() == 0 && car.getUuid() == null) {
            log.error("Update failed: Car entity must have an ID or UUID for update.");
            throw new IllegalArgumentException("Car ID or UUID must be provided for update.");
        }

        // Fetch existing to ensure it's not deleted and to apply changes to a managed entity
        Optional<Car> existingCarOpt;
        if (car.getUuid() != null) {
            existingCarOpt = carRepository.findByUuidAndDeletedFalse(car.getUuid());
        } else { // Fallback to ID if UUID not provided in 'car' object for update
            existingCarOpt = carRepository.findByIdAndDeletedFalse(car.getId());
        }

        if (existingCarOpt.isPresent()) {
            Car existingCar = existingCarOpt.get();
            log.debug("Found existing car for update: ID: {}, UUID: '{}'", existingCar.getId(), existingCar.getUuid());

            // Apply changes from 'car' (parameter) to 'existingCar'
            // This pattern is safer for updates with JPA.
      /*      existingCar.setMake(car.getMake());
            existingCar.setModel(car.getModel());
            existingCar.setYear(car.getYear());
            existingCar.setCategory(car.getCategory());
            existingCar.setPriceGroup(car.getPriceGroup());
            existingCar.setLicensePlate(car.getLicensePlate());
            if (car.getAvailable() != null) existingCar.setAvailable(car.getAvailable());*/
            Car existingCarWithUpdates = new Car.Builder()
                    .copy(existingCar)
                    .make(car.getMake())
                    .model(car.getModel())
                    .year(car.getYear())
                    .category(car.getCategory())
                    .priceGroup(car.getPriceGroup())
                    .licensePlate(car.getLicensePlate())
                    .available(car.isAvailable() ? car.isAvailable() : existingCar.isAvailable())
                    .build();
            // Do NOT update 'deleted' flag here; use delete() method for that.
            // Do NOT update UUID.

            Car updatedCar = carRepository.save(existingCarWithUpdates);
            log.info("Successfully updated car. ID: {}, UUID: '{}', Make: '{}'",
                    updatedCar.getId(), updatedCar.getUuid(), updatedCar.getMake());
            return updatedCar;
        }
        log.warn("Update failed: Car not found or is deleted for ID/UUID provided in update object (ID: {}, UUID: '{}').", car.getId(), car.getUuid());
        // Or throw ResourceNotFoundException("Car not found for update.")
        return null;
    }


    /**
     * {@inheritDoc}
     */
    @Override
    public boolean delete(Integer id) {
        log.info("Attempting to soft-delete car with internal ID: {}", id);
        return carRepository.findByIdAndDeletedFalse(id).map(car -> {
            log.debug("Found car for soft-deletion. ID: {}, UUID: '{}'", id, car.getUuid());
            // Set the deleted flag to true and mark as unavailable
            Car savedCar = carRepository.findByIdAndDeletedFalse(id)
                    .orElseThrow(() -> new ResourceNotFoundException("Car not found for ID: " + id));
            Car deletedCar = new Car.Builder()
                    .copy(savedCar)
                    .deleted(true)
                    .available(false) // Mark as unavailable when deleted
                    .build();

            carRepository.save(deletedCar);
            log.info("Successfully soft-deleted car ID: {}", id);
            return true;
        }).orElseGet(() -> {
            log.warn("Soft-delete failed: Car not found or already deleted for ID: {}", id);
            return false;
        });
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean delete(UUID uuid) {
        log.info("Attempting to soft-delete car with UUID: '{}'", uuid);
        return carRepository.findByUuidAndDeletedFalse(uuid).map(car -> {
            log.debug("Found car for soft-deletion. UUID: '{}', ID: {}", uuid, car.getId());
            // Set the deleted flag to true and mark as unavailable
            // Assuming Car is using Builder pattern
            Car savedCar = carRepository.findByUuidAndDeletedFalse(uuid).orElseThrow();
            savedCar = new Car.Builder()
                    .copy(savedCar)
                    .deleted(true)
                    .available(false) // Mark as unavailable when deleted
                    .build();
            carRepository.save(savedCar);
            log.info("Successfully soft-deleted car UUID: '{}'", uuid);
            return true;
        }).orElseGet(() -> {
            log.warn("Soft-delete failed: Car not found or already deleted for UUID: '{}'", uuid);
            return false;
        });
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public List<Car> getAll() {
        log.debug("Fetching all non-deleted cars.");
        List<Car> allCars =  this.carRepository.findByDeletedFalse();
        log.debug("Retrieved {} non-deleted cars.", allCars.size());
        return allCars;
    }

    @Override
    public List<Car> getAllAvailableCars() {
        return carRepository.findAllByAvailableTrueAndDeletedFalse();
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public List<Car> getCarsByPriceGroup(PriceGroup priceGroup) {
        log.debug("Fetching non-deleted cars by price group: {}", priceGroup);
        List<Car> cars = carRepository.findByPriceGroupAndDeletedFalse(priceGroup);
        log.debug("Found {} cars for price group: {}", cars.size(), priceGroup);
        return cars;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public List<Car> findAllAvailableAndNonDeleted() {
        log.debug("Fetching all available and non-deleted cars.");
        List<Car> availableCars = this.carRepository.findAllByAvailableTrueAndDeletedFalse();
        log.debug("Found {} available and non-deleted cars.", availableCars.size());
        return availableCars;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public List<Car> getAvailableCarsByPrice(PriceGroup priceGroup) {
        log.debug("Fetching available and non-deleted cars by price group: {}", priceGroup);
        // This method name in service matches what repository likely has.
        List<Car> cars = carRepository.findAllByAvailableTrueAndDeletedFalseAndPriceGroup(priceGroup);
        log.debug("Found {} available cars for price group: {}", cars.size(), priceGroup);
        return cars;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public List<Car> findAllAvailableByCategory(String category) {
        log.debug("Fetching available and non-deleted cars by category: '{}'", category);
        List<Car> cars = this.carRepository.findAllByAvailableTrueAndDeletedFalseAndCategory(category);
        log.debug("Found {} available cars for category: '{}'", cars.size(), category);
        return cars;
    }

    @Override
    public List<Car> findAllAvailableByPriceGroup(PriceGroup priceGroup) {
        return carRepository.findAllByAvailableTrueAndDeletedFalseAndPriceGroup(priceGroup);
    }
}